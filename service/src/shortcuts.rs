use std::env;
use std::fs;
use std::path::PathBuf;
use tracing::{info, warn, error};

#[cfg(target_os = "windows")]
pub fn get_shortcut_paths() -> Result<(PathBuf, PathBuf), String> {
    // Use ALLUSERSPROFILE for all-users Start Menu
    let start_menu_base = env::var("ALLUSERSPROFILE")
        .or_else(|_| env::var("PROGRAMDATA"))
        .map_err(|_| "Neither ALLUSERSPROFILE nor PROGRAMDATA environment variable found".to_string())?;
    let start_menu = PathBuf::from(start_menu_base).join(r"Microsoft\Windows\Start Menu\Programs\Framework Control.lnk");

    // Use PUBLIC for all-users Desktop
    let desktop_base = env::var("PUBLIC")
        .map_err(|_| "PUBLIC environment variable not found".to_string())?;
    let desktop = PathBuf::from(desktop_base).join(r"Desktop\Framework Control.lnk");

    Ok((start_menu, desktop))
}

#[cfg(not(target_os = "windows"))]
pub fn get_shortcut_paths() -> Result<(PathBuf, PathBuf), String> {
    Err("Shortcuts only supported on Windows".to_string())
}

pub fn shortcuts_exist() -> bool {
    match get_shortcut_paths() {
        Ok((start_menu, desktop)) => start_menu.exists() && desktop.exists(),
        Err(_) => false,
    }
}

#[cfg(all(target_os = "windows", feature = "embed-ui"))]
fn extract_icon() -> Result<PathBuf, String> {
    // Place icon where both SYSTEM and users can access: ProgramData\FrameworkControl\assets
    let program_data = env::var("PROGRAMDATA")
        .map_err(|_| "PROGRAMDATA environment variable not found".to_string())?;
    let assets_dir = PathBuf::from(program_data).join(r"FrameworkControl\assets");
    fs::create_dir_all(&assets_dir).map_err(|e| format!("Failed to create assets dir: {}", e))?;

    // ICO embedded at compile-time (generated by web build prior to service build)
    let ico_bytes: &[u8] = include_bytes!(concat!(
        env!("CARGO_MANIFEST_DIR"),
        "/../web/public/assets/generated/logo.ico"
    ));
    let ico_dest = assets_dir.join("framework-control.ico");
    fs::write(&ico_dest, ico_bytes).map_err(|e| format!("Failed to write ICO: {}", e))?;
    Ok(ico_dest)
}

#[cfg(all(target_os = "windows", not(feature = "embed-ui")))]
fn extract_icon() -> Result<PathBuf, String> {
    Err("Icon not embedded (embed-ui feature disabled)".to_string())
}

#[cfg(not(target_os = "windows"))]
fn extract_icon() -> Result<PathBuf, String> {
    Err("Icon extraction only supported on Windows".to_string())
}

#[cfg(target_os = "windows")]
pub async fn create_shortcuts(port: u16) -> Result<(), String> {
    let (start_menu_path, desktop_path) = get_shortcut_paths()?;

    // Log resolved paths for diagnostics
    info!(
        "shortcuts: start_menu='{}', desktop='{}'",
        start_menu_path.display(),
        desktop_path.display()
    );

    // Extract icon from embedded assets to temp location
    let icon_path = extract_icon()?;
    info!("shortcuts: icon_path='{}'", icon_path.display());

    // Load PowerShell script template from scripts/create_shortcuts.ps1 and inject values
    let template: &str = include_str!(concat!(
        env!("CARGO_MANIFEST_DIR"),
        "/scripts/create_shortcuts.ps1"
    ));
    let ps_script = template
        .replace("{PORT}", &port.to_string())
        .replace("{ICON}", &icon_path.display().to_string())
        .replace("{START_MENU}", &start_menu_path.display().to_string())
        .replace("{DESKTOP}", &desktop_path.display().to_string());

    // Execute PowerShell script
    let output = tokio::process::Command::new("powershell")
        .arg("-NoProfile")
        .arg("-ExecutionPolicy")
        .arg("Bypass")
        .arg("-Command")
        .arg(&ps_script)
        .output()
        .await
        .map_err(|e| format!("Failed to execute PowerShell: {}", e))?;

    if !output.status.success() {
        let stderr = String::from_utf8_lossy(&output.stderr);
        return Err(format!("PowerShell script failed: {}", stderr));
    }

    Ok(())
}

#[cfg(not(target_os = "windows"))]
pub async fn create_shortcuts(_port: u16) -> Result<(), String> {
    Err("Shortcuts are only supported on Windows".to_string())
}

/// Check for installer marker file and create shortcuts if present
/// This is called once on service startup to handle the "create shortcuts on first run" option
pub async fn create_shortcuts_if_installer_requested() {
    // Look for marker file in the same directory as the executable
    let marker_path = match env::current_exe() {
        Ok(exe) => match exe.parent() {
            Some(dir) => dir.join("create_shortcuts.flag"),
            None => return,
        },
        Err(_) => return,
    };
    
    if !marker_path.exists() {
        return;
    }
    
    info!("Installer shortcut request detected, creating shortcuts...");
    
    // Get port from environment (required for service to run)
    let port = match env::var("FRAMEWORK_CONTROL_PORT") {
        Ok(p) => match p.parse::<u16>() {
            Ok(port) => port,
            Err(e) => {
                error!("Invalid FRAMEWORK_CONTROL_PORT: {}", e);
                return;
            }
        },
        Err(_) => {
            error!("FRAMEWORK_CONTROL_PORT not set, cannot create shortcuts");
            return;
        }
    };
    
    // Create shortcuts
    match create_shortcuts(port).await {
        Ok(_) => {
            info!("Shortcuts created successfully");
            // Remove marker file so we don't create shortcuts again
            if let Err(e) = fs::remove_file(&marker_path) {
                warn!("Failed to remove shortcut marker file: {}", e);
            }
        }
        Err(e) => error!("Failed to create shortcuts: {}", e),
    }
}
